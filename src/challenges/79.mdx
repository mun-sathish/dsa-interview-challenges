### [Word Search](https://leetcode.com/problems/word-search/)

- Use DFS/backtracking to explore all paths
- Mark visited cells temporarily during search
- Restore cell after exploring (backtrack)
- Check all four directions from each cell

#### Visual Explanation

**DFS Search Process:**
```
Board:          Word: "ABCCED"
[A,B,C,E]
[S,F,C,S]       Start at A(0,0)
[A,D,E,E]       â†’ B(0,1) â†’ C(0,2) â†’ C(1,2)
                â†’ E(1,3) â†’ D(2,1) âœ—
                Backtrack and try E(2,2) âœ“

Mark visited: '#'
Restore after exploring
```

ðŸ“º [Watch Visual Explanation](https://www.youtube.com/watch?v=pfiQ_PS1g8E)

```js copy
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function(board, word) {
    const m = board.length;
    const n = board[0].length;
    
    function dfs(i, j, index) {
        // Found complete word
        if (index === word.length) return true;
        
        // Out of bounds or wrong character
        if (i < 0 || i >= m || j < 0 || j >= n || 
            board[i][j] !== word[index]) {
            return false;
        }
        
        // Mark as visited
        const temp = board[i][j];
        board[i][j] = '#';
        
        // Explore all 4 directions
        const found = dfs(i + 1, j, index + 1) ||
                      dfs(i - 1, j, index + 1) ||
                      dfs(i, j + 1, index + 1) ||
                      dfs(i, j - 1, index + 1);
        
        // Restore cell (backtrack)
        board[i][j] = temp;
        
        return found;
    }
    
    // Try starting from each cell
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (dfs(i, j, 0)) {
                return true;
            }
        }
    }
    
    return false;
};
```

##### Complexity

- Time: O(m Ã— n Ã— 4^L) where L is word length
- Space: O(L) for recursion stack