### [Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/)

- Use min heap to track end times of ongoing meetings
- Sort intervals by start time
- For each meeting, check if earliest ending meeting has finished
- Heap size represents minimum rooms needed

```js copy
/**
 * @param {number[][]} intervals
 * @return {number}
 */
var minMeetingRooms = function(intervals) {
    if (intervals.length === 0) return 0;
    
    // Sort by start time
    intervals.sort((a, b) => a[0] - b[0]);
    
    // Min heap to track end times (using array for simplicity)
    const endTimes = [intervals[0][1]];
    
    for (let i = 1; i < intervals.length; i++) {
        // Sort to maintain min heap property
        endTimes.sort((a, b) => a - b);
        
        // If earliest meeting has ended, reuse the room
        if (endTimes[0] <= intervals[i][0]) {
            endTimes.shift();
        }
        
        // Add current meeting's end time
        endTimes.push(intervals[i][1]);
    }
    
    return endTimes.length;
};

// Alternative: Using separate start and end arrays
var minMeetingRoomsOptimized = function(intervals) {
    const starts = intervals.map(i => i[0]).sort((a, b) => a - b);
    const ends = intervals.map(i => i[1]).sort((a, b) => a - b);
    
    let rooms = 0;
    let endIdx = 0;
    
    for (let i = 0; i < starts.length; i++) {
        if (starts[i] < ends[endIdx]) {
            rooms++;
        } else {
            endIdx++;
        }
    }
    
    return rooms;
};
```

##### Complexity

- Time: O(n log n) for sorting
- Space: O(n) for heap/arrays