### [Course Schedule](https://leetcode.com/problems/course-schedule/)

- Use topological sort to detect cycles in directed graph
- Build adjacency list and track in-degrees
- Use BFS/DFS to process courses with no prerequisites first
- If we can process all courses, return true

#### Visual Explanation

**Topological Sort (Kahn's Algorithm):**
```
Courses: 4, Prerequisites: [[1,0],[2,0],[3,1],[3,2]]

Graph:        0 â†’ 1 â†’ 3
              â†“   â†—
              2 â”€â”€â”˜

In-degrees:   0:0, 1:1, 2:1, 3:2

Step 1: Start with in-degree 0
  Queue: [0]
  Process 0 â†’ reduce in-degrees of 1,2
  In-degrees: 1:0, 2:0, 3:2
  
Step 2: Add courses with in-degree 0
  Queue: [1, 2]
  Process 1 â†’ reduce in-degree of 3
  In-degrees: 2:0, 3:1
  
Step 3: Continue
  Queue: [2]
  Process 2 â†’ reduce in-degree of 3
  In-degrees: 3:0
  
Step 4: Final course
  Queue: [3]
  Process 3
  
Processed: 4 courses = total courses âœ“
Can finish all courses!

If cycle exists: Some courses remain unprocessed
```

**Key insight:**
```
Topological sort works âŸº No cycles
Count processed courses = total âŸº Can finish
```

ðŸ“º [Watch Visual Explanation](https://www.youtube.com/watch?v=EgI5nU9etnU)

```js copy
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */
var canFinish = function(numCourses, prerequisites) {
    const graph = Array.from({ length: numCourses }, () => []);
    const inDegree = Array(numCourses).fill(0);
    
    // Build graph and calculate in-degrees
    for (let [course, prereq] of prerequisites) {
        graph[prereq].push(course);
        inDegree[course]++;
    }
    
    // Start with courses that have no prerequisites
    const queue = [];
    for (let i = 0; i < numCourses; i++) {
        if (inDegree[i] === 0) {
            queue.push(i);
        }
    }
    
    let count = 0;
    while (queue.length > 0) {
        const course = queue.shift();
        count++;
        
        for (let next of graph[course]) {
            inDegree[next]--;
            if (inDegree[next] === 0) {
                queue.push(next);
            }
        }
    }
    
    return count === numCourses;
};
```

##### Complexity

- Time: O(V + E) where V is courses and E is prerequisites
- Space: O(V + E) for graph and queue