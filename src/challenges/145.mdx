### [Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/)

- **Postorder**: Left â†’ Right â†’ Root
- **Recursive**: Simple and intuitive
- **Iterative**: Use two stacks or reverse preorder

#### Visual Explanation

**Postorder Traversal (Left â†’ Right â†’ Root):**
```
Tree:       1
           / \
          2   3
         / \
        4   5

Recursive Execution:
visit(1) â†’ visit(2) â†’ visit(4)
           â†“          â†“
         visit(null) output 4 â†’ [4]
           â†“
         visit(5) â†’ output 5 â†’ [4,5]
           â†“
         output 2 â†’ [4,5,2]
           â†“
       visit(3) â†’ output 3 â†’ [4,5,2,3]
           â†“
       output 1 â†’ [4,5,2,3,1] âœ“

Two-Stack Method:
Stack1: [1]        â†’ Stack2: [1]
Stack1: [2,3]      â†’ Stack2: [1,3,2]
Stack1: [4,5]      â†’ Stack2: [1,3,2,5,4]
Stack1: []
Pop Stack2: [4,5,2,3,1] âœ“

Reverse Preorder Trick:
Preorder: Root-Left-Right = [1,2,4,5,3]
Modified: Root-Right-Left = [1,3,2,5,4]
Reverse: [4,5,2,3,1] = Postorder! âœ“
```

**Key insight:**
```
Postorder = Left subtree + Right subtree + Root
Process node AFTER visiting all children
```

ðŸ“º [Watch Visual Explanation](https://www.youtube.com/watch?v=QhszUQhGGlA)

```js copy
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */

// Recursive Solution
var postorderTraversal = function(root) {
    const result = [];
    
    function traverse(node) {
        if (!node) return;
        traverse(node.left);         // Left
        traverse(node.right);        // Right
        result.push(node.val);       // Root
    }
    
    traverse(root);
    return result;
};

// Iterative Solution using Two Stacks
var postorderTraversalIterative = function(root) {
    if (!root) return [];
    
    const result = [];
    const stack1 = [root];
    const stack2 = [];
    
    while (stack1.length > 0) {
        const node = stack1.pop();
        stack2.push(node);
        
        if (node.left) stack1.push(node.left);
        if (node.right) stack1.push(node.right);
    }
    
    while (stack2.length > 0) {
        result.push(stack2.pop().val);
    }
    
    return result;
};

// Alternative: Reverse Preorder (Root-Right-Left) to get Postorder
var postorderTraversalReverse = function(root) {
    if (!root) return [];
    
    const result = [];
    const stack = [root];
    
    while (stack.length > 0) {
        const node = stack.pop();
        result.push(node.val);
        
        // Push left first so right is processed first
        if (node.left) stack.push(node.left);
        if (node.right) stack.push(node.right);
    }
    
    return result.reverse();
};
```

##### Complexity

- Time: O(n) where n is number of nodes
- Space: O(h) for recursion stack or O(n) for iterative with two stacks