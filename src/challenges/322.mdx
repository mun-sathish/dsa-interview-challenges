### [Coin Change](https://leetcode.com/problems/coin-change/)

- **DP Pattern**: Minimum coins to make amount
- Bottom-up approach: dp[i] = min coins for amount i
- For each amount, try all coins and take minimum
- Classic unbounded knapsack problem

#### Visual Explanation

**DP Table Building (coins=[1,2,5], amount=11):**
```
Amount:  0  1  2  3  4  5  6  7  8  9  10  11
dp[]:    0  âˆž  âˆž  âˆž  âˆž  âˆž  âˆž  âˆž  âˆž  âˆž  âˆž   âˆž

After coin=1:
dp[]:    0  1  2  3  4  5  6  7  8  9  10  11

After coin=2:
dp[]:    0  1  1  2  2  3  3  4  4  5  5   6

After coin=5:
dp[]:    0  1  1  2  2  1  2  2  3  3  2   3 âœ“

For amount=11:
- Use coin 5: dp[11] = dp[6] + 1 = 2 + 1 = 3
- Use coin 2: dp[11] = dp[9] + 1 = 3 + 1 = 4
- Use coin 1: dp[11] = dp[10] + 1 = 2 + 1 = 3
Result: 3 coins (5+5+1)
```

**Key insight:**
```
dp[i] = min(dp[i], dp[i - coin] + 1)
        â†‘           â†‘
     current    use this coin
```

ðŸ“º [Watch Visual Explanation](https://www.youtube.com/watch?v=H9bfqozjoqs)

```js copy
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function(coins, amount) {
    // dp[i] = minimum coins needed for amount i
    const dp = Array(amount + 1).fill(Infinity);
    dp[0] = 0; // 0 coins needed for amount 0
    
    for (let i = 1; i <= amount; i++) {
        for (let coin of coins) {
            if (i >= coin) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    
    return dp[amount] === Infinity ? -1 : dp[amount];
};
```

##### Complexity

- Time: O(amount * coins.length)
- Space: O(amount) for dp array