### [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)

- **Level Order**: Process nodes level by level from left to right
- **Use Queue (BFS)**: Track level size for grouping
- **Iterative approach**: Most common for level order

#### Visual Explanation

**Level Order BFS:**
```
Tree:       3
           / \
          9   20
             /  \
            15   7

BFS Queue Evolution:

Level 0:
Queue: [3]
Process: 3
Result: [[3]]
Add children: 9, 20

Level 1:
Queue: [9, 20]
levelSize = 2
Process: 9, 20
Result: [[3], [9,20]]
Add children: 15, 7

Level 2:
Queue: [15, 7]
levelSize = 2
Process: 15, 7
Result: [[3], [9,20], [15,7]] âœ“

Key: Track levelSize before processing each level
```

**Key insight:**
```
BFS with level tracking:
1. Record queue size at start of each level
2. Process exactly that many nodes
3. All children go to next level
```

ðŸ“º [Watch Visual Explanation](https://www.youtube.com/watch?v=6ZnyEApgFYg)

```js copy
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */

// Iterative Solution using Queue (BFS)
var levelOrder = function(root) {
    if (!root) return [];
    
    const result = [];
    const queue = [root];
    
    while (queue.length > 0) {
        const levelSize = queue.length;
        const currentLevel = [];
        
        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();
            currentLevel.push(node.val);
            
            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
        
        result.push(currentLevel);
    }
    
    return result;
};

// Recursive Solution (less common but possible)
var levelOrderRecursive = function(root) {
    const result = [];
    
    function traverse(node, level) {
        if (!node) return;
        
        if (result.length === level) {
            result.push([]);
        }
        
        result[level].push(node.val);
        traverse(node.left, level + 1);
        traverse(node.right, level + 1);
    }
    
    traverse(root, 0);
    return result;
};
```

##### Complexity

- Time: O(n) where n is number of nodes
- Space: O(w) where w is maximum width of tree (queue size)