# All DSA Patterns Guide

A comprehensive guide to all Data Structures and Algorithms patterns with detailed explanations, visualizations, and examples.

---

## Table of Contents

1. [Two Pointers](#two-pointers)
2. [Sliding Window](#sliding-window)
3. [Fast & Slow Pointers](#fast--slow-pointers)
4. [Binary Search](#binary-search)
5. [Depth-First Search (DFS)](#depth-first-search-dfs)
6. [Breadth-First Search (BFS)](#breadth-first-search-bfs)
7. [Dynamic Programming](#dynamic-programming)
8. [Backtracking](#backtracking)
9. [Greedy Algorithms](#greedy-algorithms)
10. [Heap / Priority Queue](#heap--priority-queue)
11. [Hash Table](#hash-table)
12. [Stack](#stack)
13. [Linked List](#linked-list)
14. [Tree Traversals](#tree-traversals)
15. [Graph Algorithms](#graph-algorithms)
16. [Intervals](#intervals)

---

## Two Pointers

### Overview
The Two Pointers pattern uses two pointers to iterate through a data structure, typically an array or linked list. The pointers can move toward each other, away from each other, or at different speeds.

### When to Use
- Searching pairs in a sorted array
- Removing duplicates from sorted arrays
- Comparing elements from both ends
- Finding subarrays or subsequences

### Visual Pattern
```
Opposite Direction:
[1, 2, 3, 4, 5, 6]
 â†‘              â†‘
 left          right

Same Direction:
[1, 2, 3, 4, 5, 6]
 â†‘  â†‘
slow fast
```

### Common Variations

#### 1. **Opposite Direction (Converging)**
```javascript
// Two Sum II - Sorted Array
function twoSum(numbers, target) {
    let left = 0;
    let right = numbers.length - 1;
    
    while (left < right) {
        const sum = numbers[left] + numbers[right];
        if (sum === target) return [left + 1, right + 1];
        if (sum < target) left++;
        else right--;
    }
    return [-1, -1];
}
```

**Time**: O(n) | **Space**: O(1)

#### 2. **Same Direction (Fast & Slow)**
```javascript
// Remove Duplicates from Sorted Array
function removeDuplicates(nums) {
    let slow = 0;
    
    for (let fast = 1; fast < nums.length; fast++) {
        if (nums[fast] !== nums[slow]) {
            slow++;
            nums[slow] = nums[fast];
        }
    }
    return slow + 1;
}
```

**Time**: O(n) | **Space**: O(1)

### Key Problems
- [Two Sum](/topics/hash-table#two-sum)
- [3Sum](/topics/two-pointers#3sum)
- [Container With Most Water](/topics/two-pointers#container-with-most-water)

---

## Sliding Window

### Overview
The Sliding Window pattern maintains a window (subarray) that slides through the array/string to find optimal solutions. The window can be fixed-size or variable-size.

### When to Use
- Finding subarrays/substrings with specific properties
- Maximum/minimum subarray problems
- String pattern matching
- Consecutive elements problems

### Visual Pattern
```
Fixed Window (size=3):
[1, 2, 3, 4, 5, 6]
 [-----]           window at position 0
    [-----]        window slides right
       [-----]     window slides right

Variable Window:
[1, 2, 3, 4, 5]
 [---]            expand when condition not met
 [-------]        contract when condition met
```

### Common Variations

#### 1. **Fixed Window Size**
```javascript
// Maximum Sum Subarray of Size K
function maxSumSubarray(arr, k) {
    let maxSum = 0;
    let windowSum = 0;
    
    // Calculate first window
    for (let i = 0; i < k; i++) {
        windowSum += arr[i];
    }
    maxSum = windowSum;
    
    // Slide window
    for (let i = k; i < arr.length; i++) {
        windowSum = windowSum - arr[i - k] + arr[i];
        maxSum = Math.max(maxSum, windowSum);
    }
    return maxSum;
}
```

**Time**: O(n) | **Space**: O(1)

#### 2. **Variable Window Size**
```javascript
// Longest Substring Without Repeating Characters
function lengthOfLongestSubstring(s) {
    const seen = new Set();
    let left = 0;
    let maxLen = 0;
    
    for (let right = 0; right < s.length; right++) {
        while (seen.has(s[right])) {
            seen.delete(s[left]);
            left++;
        }
        seen.add(s[right]);
        maxLen = Math.max(maxLen, right - left + 1);
    }
    return maxLen;
}
```

**Time**: O(n) | **Space**: O(min(n, m)) where m is charset size

### Template
```javascript
function slidingWindow(arr) {
    let left = 0;
    let result = 0;
    
    for (let right = 0; right < arr.length; right++) {
        // Expand window: add arr[right] to window
        
        while (/* window condition violated */) {
            // Contract window: remove arr[left] from window
            left++;
        }
        
        // Update result
        result = Math.max(result, right - left + 1);
    }
    return result;
}
```

### Key Problems
- [Longest Substring Without Repeating Characters](/topics/sliding-window#longest-substring-without-repeating-characters)
- [Minimum Window Substring](/topics/sliding-window#minimum-window-substring)
- [Longest Repeating Character Replacement](/topics/sliding-window#longest-repeating-character-replacement)

---

## Fast & Slow Pointers

### Overview
Also known as the "Tortoise and Hare" algorithm, this pattern uses two pointers moving at different speeds to detect cycles or find middle elements.

### When to Use
- Detecting cycles in linked lists
- Finding middle of linked list
- Detecting palindromes
- Finding cycle start point

### Visual Pattern
```
Cycle Detection:
1 â†’ 2 â†’ 3 â†’ 4 â†’ 5
         â†‘       â†“
         8 â† 7 â† 6

slow: 1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6 â†’ 7 â†’ 8 â†’ 3...
fast: 1 â†’ 3 â†’ 5 â†’ 7 â†’ 3 â†’ 7 â†’ 3...
      They meet at some point in cycle!
```

### Implementation
```javascript
// Detect Cycle in Linked List
function hasCycle(head) {
    let slow = head;
    let fast = head;
    
    while (fast && fast.next) {
        slow = slow.next;           // Move 1 step
        fast = fast.next.next;      // Move 2 steps
        
        if (slow === fast) {
            return true;  // Cycle detected
        }
    }
    return false;  // No cycle
}

// Find Middle of Linked List
function findMiddle(head) {
    let slow = head;
    let fast = head;
    
    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;  // Middle node
}
```

**Time**: O(n) | **Space**: O(1)

### Key Problems
- [Linked List Cycle](/topics/linked-list#linked-list-cycle)
- [Happy Number](/topics/hash-table#happy-number)
- [Find Duplicate Number](/topics/array#find-duplicate-number)

---

## Binary Search

### Overview
Binary Search is a divide-and-conquer algorithm that efficiently finds a target value in a sorted array by repeatedly dividing the search interval in half.

### When to Use
- Searching in sorted arrays
- Finding boundaries (first/last occurrence)
- Optimization problems (minimize/maximize)
- Search in rotated sorted arrays

### Visual Pattern
```
Array: [1, 3, 5, 7, 9, 11, 13, 15]
Target: 7

Step 1: [1, 3, 5, 7, 9, 11, 13, 15]
         L        M              R
         mid = 9 > 7, search left

Step 2: [1, 3, 5, 7]
         L     M  R
         mid = 5 < 7, search right

Step 3: [7]
         L/M/R
         Found!
```

### Templates

#### 1. **Standard Binary Search**
```javascript
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
        const mid = left + Math.floor((right - left) / 2);
        
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}
```

**Time**: O(log n) | **Space**: O(1)

#### 2. **Modified Binary Search (Search Space Reduction)**

Modified binary search applies the binary search principle to problems where the search space isn't explicitly an array. The key insight is identifying a monotonic property that allows elimination of half the search space.

**Common Use Cases:**
- Finding minimum/maximum in rotated sorted arrays
- Search in 2D matrices
- Finding peak elements
- Optimization problems (minimize/maximize a value)
- Finding square roots, nth roots
- Capacity/allocation problems

**Template for Modified Binary Search:**
```javascript
function modifiedBinarySearch(searchSpace) {
    let left = minValue;
    let right = maxValue;
    
    while (left < right) {
        const mid = left + Math.floor((right - left) / 2);
        
        if (isValid(mid)) {
            // If mid satisfies condition, search left half
            right = mid;
        } else {
            // Otherwise, search right half
            left = mid + 1;
        }
    }
    
    return left;  // or right, they're equal
}
```

**Example: Find Minimum in Rotated Sorted Array**
```javascript
function findMin(nums) {
    let left = 0;
    let right = nums.length - 1;
    
    while (left < right) {
        const mid = left + Math.floor((right - left) / 2);
        
        // If mid element is greater than rightmost element,
        // minimum must be in right half
        if (nums[mid] > nums[right]) {
            left = mid + 1;
        } else {
            // Otherwise, minimum is in left half (including mid)
            right = mid;
        }
    }
    
    return nums[left];
}
```

**Example: Search in Rotated Sorted Array**
```javascript
function search(nums, target) {
    let left = 0;
    let right = nums.length - 1;
    
    while (left <= right) {
        const mid = left + Math.floor((right - left) / 2);
        
        if (nums[mid] === target) return mid;
        
        // Determine which half is sorted
        if (nums[left] <= nums[mid]) {
            // Left half is sorted
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            // Right half is sorted
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    
    return -1;
}
```

**Key Insight**: Modified binary search works when you can define a condition that divides the search space into two parts where one part definitely doesn't contain the answer.

### Key Problems
- [Binary Search](/topics/binary-search#binary-search)
- [Search in Rotated Sorted Array](/topics/binary-search#search-in-rotated-sorted-array)
- [Find Minimum in Rotated Sorted Array](/topics/binary-search#find-minimum-in-rotated-sorted-array)

---

## Depth-First Search (DFS)

### Overview
DFS explores as far as possible along each branch before backtracking. It uses a stack (or recursion) to keep track of nodes to visit.

### When to Use
- Tree/graph traversal
- Finding paths
- Detecting cycles
- Topological sorting
- Connected components

### Visual Pattern
```
Tree DFS Traversal:
        1
       / \
      2   3
     / \
    4   5

Preorder (Root-Left-Right):  1 â†’ 2 â†’ 4 â†’ 5 â†’ 3
Inorder (Left-Root-Right):   4 â†’ 2 â†’ 5 â†’ 1 â†’ 3
Postorder (Left-Right-Root): 4 â†’ 5 â†’ 2 â†’ 3 â†’ 1
```

### Tree Traversal Types

#### 1. **Preorder Traversal (Root-Left-Right)**

**When to Use:**
- Creating a copy of the tree
- Getting prefix expression of an expression tree
- Serializing a tree structure
- Tree construction problems

**Use Cases:**
- Serialize/deserialize binary tree
- Flatten binary tree to linked list
- Path sum problems (checking from root)

**Recursive Implementation:**
```javascript
function preorderTraversal(root) {
    const result = [];
    
    function traverse(node) {
        if (!node) return;
        
        result.push(node.val);      // Process root first
        traverse(node.left);         // Then left subtree
        traverse(node.right);        // Then right subtree
    }
    
    traverse(root);
    return result;
}
```

**Iterative Implementation:**
```javascript
function preorderIterative(root) {
    if (!root) return [];
    
    const result = [];
    const stack = [root];
    
    while (stack.length > 0) {
        const node = stack.pop();
        result.push(node.val);
        
        // Push right first so left is processed first
        if (node.right) stack.push(node.right);
        if (node.left) stack.push(node.left);
    }
    
    return result;
}
```

#### 2. **Inorder Traversal (Left-Root-Right)**

**When to Use:**
- Getting values in sorted order from BST
- Validating BST
- Finding kth smallest/largest in BST
- Converting BST to sorted array

**Use Cases:**
- Binary Search Tree validation
- Kth smallest element in BST
- Recover Binary Search Tree
- Inorder successor/predecessor

**Recursive Implementation:**
```javascript
function inorderTraversal(root) {
    const result = [];
    
    function traverse(node) {
        if (!node) return;
        
        traverse(node.left);         // Process left subtree first
        result.push(node.val);       // Then root
        traverse(node.right);        // Then right subtree
    }
    
    traverse(root);
    return result;
}
```

**Iterative Implementation:**
```javascript
function inorderIterative(root) {
    const result = [];
    const stack = [];
    let current = root;
    
    while (current || stack.length > 0) {
        // Go to leftmost node
        while (current) {
            stack.push(current);
            current = current.left;
        }
        
        // Process node
        current = stack.pop();
        result.push(current.val);
        
        // Move to right subtree
        current = current.right;
    }
    
    return result;
}
```

**Key Property**: For BST, inorder traversal gives nodes in ascending order!

#### 3. **Postorder Traversal (Left-Right-Root)**

**When to Use:**
- Deleting a tree (delete children before parent)
- Getting postfix expression of an expression tree
- Bottom-up calculations (height, diameter)
- Dependency resolution

**Use Cases:**
- Delete nodes in a tree
- Calculate tree height/diameter
- Lowest Common Ancestor
- Binary tree maximum path sum

**Recursive Implementation:**
```javascript
function postorderTraversal(root) {
    const result = [];
    
    function traverse(node) {
        if (!node) return;
        
        traverse(node.left);         // Process left subtree first
        traverse(node.right);        // Then right subtree
        result.push(node.val);       // Then root (after children)
    }
    
    traverse(root);
    return result;
}
```

**Iterative Implementation:**
```javascript
function postorderIterative(root) {
    if (!root) return [];
    
    const result = [];
    const stack = [root];
    
    while (stack.length > 0) {
        const node = stack.pop();
        result.unshift(node.val);  // Add to front
        
        // Push left first so right is processed first
        if (node.left) stack.push(node.left);
        if (node.right) stack.push(node.right);
    }
    
    return result;
}
```

### Graph DFS Implementation

```javascript
// Graph DFS (for connected components, cycle detection, etc.)
function dfsGraph(graph, start, visited = new Set()) {
    visited.add(start);
    console.log(start);
    
    for (let neighbor of graph[start]) {
        if (!visited.has(neighbor)) {
            dfsGraph(graph, neighbor, visited);
        }
    }
}
```

### Traversal Comparison

| Traversal | Order | Best For | Example Problems |
|-----------|-------|----------|------------------|
| **Preorder** | Root â†’ Left â†’ Right | Tree copying, serialization | Flatten tree, serialize tree |
| **Inorder** | Left â†’ Root â†’ Right | BST operations, sorted output | Validate BST, kth smallest |
| **Postorder** | Left â†’ Right â†’ Root | Tree deletion, bottom-up calc | Tree height, LCA, delete nodes |

**Time**: O(V + E) for graphs, O(n) for trees | **Space**: O(h) where h is height

### Key Problems
- [Number of Islands](/topics/graph#number-of-islands)
- [Clone Graph](/topics/graph#clone-graph)
- [All Paths From Source to Target](/topics/graph#all-paths-from-source-to-target)

---

## Breadth-First Search (BFS)

### Overview
BFS explores all nodes at the current depth before moving to nodes at the next depth level. It uses a queue to keep track of nodes to visit.

### When to Use
- Shortest path in unweighted graphs
- Level-order traversal
- Finding nearest neighbors
- Minimum steps problems

### Visual Pattern
```
Tree BFS (Level Order):
        1
       / \
      2   3
     / \   \
    4   5   6

Level 0: [1]
Level 1: [2, 3]
Level 2: [4, 5, 6]

Queue evolution:
[1] â†’ [2,3] â†’ [3,4,5] â†’ [4,5,6] â†’ [5,6] â†’ [6] â†’ []
```

### Implementations

#### 1. **Standard BFS**
```javascript
function bfs(root) {
    if (!root) return;
    
    const queue = [root];
    
    while (queue.length > 0) {
        const node = queue.shift();
        console.log(node.val);
        
        if (node.left) queue.push(node.left);
        if (node.right) queue.push(node.right);
    }
}
```

#### 2. **Level-Order BFS**
```javascript
function levelOrder(root) {
    if (!root) return [];
    
    const result = [];
    const queue = [root];
    
    while (queue.length > 0) {
        const levelSize = queue.length;
        const currentLevel = [];
        
        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();
            currentLevel.push(node.val);
            
            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
        
        result.push(currentLevel);
    }
    return result;
}
```

**Time**: O(V + E) for graphs, O(n) for trees | **Space**: O(w) where w is max width

### Key Problems
- [Binary Tree Level Order Traversal](/topics/tree#binary-tree-level-order-traversal)
- [Rotting Oranges](/topics/graph#rotting-oranges)
- [Word Ladder](/topics/graph#word-ladder)

---

## Dynamic Programming

### Overview
Dynamic Programming solves complex problems by breaking them down into simpler subproblems and storing their solutions to avoid redundant calculations.

### When to Use
- Optimization problems (min/max)
- Counting problems
- Problems with overlapping subproblems
- Problems with optimal substructure

### Core Concepts

#### 1. **Memoization (Top-Down)**
```javascript
// Fibonacci with Memoization
function fib(n, memo = {}) {
    if (n <= 1) return n;
    if (memo[n]) return memo[n];
    
    memo[n] = fib(n - 1, memo) + fib(n - 2, memo);
    return memo[n];
}
```

#### 2. **Tabulation (Bottom-Up)**
```javascript
// Fibonacci with Tabulation
function fib(n) {
    if (n <= 1) return n;
    
    const dp = [0, 1];
    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

### Common DP Patterns

#### 1. **Linear DP (1D)**
```javascript
// House Robber
function rob(nums) {
    if (nums.length === 0) return 0;
    if (nums.length === 1) return nums[0];
    
    const dp = [nums[0], Math.max(nums[0], nums[1])];
    
    for (let i = 2; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
    }
    return dp[nums.length - 1];
}
```

**Pattern**: `dp[i] = f(dp[i-1], dp[i-2], ...)`

#### 2. **Grid DP (2D)**
```javascript
// Unique Paths
function uniquePaths(m, n) {
    const dp = Array(m).fill().map(() => Array(n).fill(1));
    
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}
```

**Pattern**: `dp[i][j] = f(dp[i-1][j], dp[i][j-1], ...)`

#### 3. **Knapsack DP**
```javascript
// 0/1 Knapsack
function knapsack(weights, values, capacity) {
    const n = weights.length;
    const dp = Array(n + 1).fill().map(() => Array(capacity + 1).fill(0));
    
    for (let i = 1; i <= n; i++) {
        for (let w = 1; w <= capacity; w++) {
            if (weights[i - 1] <= w) {
                dp[i][w] = Math.max(
                    dp[i - 1][w],
                    dp[i - 1][w - weights[i - 1]] + values[i - 1]
                );
            } else {
                dp[i][w] = dp[i - 1][w];
            }
        }
    }
    return dp[n][capacity];
}
```

### DP Problem-Solving Steps
1. **Define the state**: What does `dp[i]` or `dp[i][j]` represent?
2. **Find the recurrence relation**: How to compute current state from previous states?
3. **Initialize base cases**: What are the starting values?
4. **Determine iteration order**: Bottom-up or top-down?
5. **Optimize space**: Can we reduce dimensions?

### Key Problems
- [Climbing Stairs](/topics/dynamic-programming#climbing-stairs)
- [Coin Change](/topics/dynamic-programming#coin-change)
- [Longest Increasing Subsequence](/topics/dynamic-programming#longest-increasing-subsequence)
- [Longest Common Subsequence](/topics/dynamic-programming#longest-common-subsequence)

---

## Backtracking

### Overview
Backtracking builds solutions incrementally and abandons solutions that fail to satisfy constraints. It's essentially DFS with pruning.

### When to Use
- Generating all combinations/permutations
- Solving constraint satisfaction problems
- Finding all solutions to a problem
- Puzzles (N-Queens, Sudoku)

### Visual Pattern
```
Generate Permutations of [1,2,3]:

                    []
           /         |         \
         [1]        [2]        [3]
        /   \      /   \      /   \
     [1,2] [1,3] [2,1] [2,3] [3,1] [3,2]
       |     |     |     |     |     |
    [1,2,3][1,3,2][2,1,3][2,3,1][3,1,2][3,2,1]
```

### Template
```javascript
function backtrack(result, current, choices) {
    // Base case: solution found
    if (isComplete(current)) {
        result.push([...current]);
        return;
    }
    
    // Try each choice
    for (let choice of choices) {
        // Make choice
        current.push(choice);
        
        // Recurse
        backtrack(result, current, getNextChoices(choices, choice));
        
        // Undo choice (backtrack)
        current.pop();
    }
}
```

### Common Patterns

#### 1. **Permutations**
```javascript
function permute(nums) {
    const result = [];
    
    function backtrack(current, remaining) {
        if (remaining.length === 0) {
            result.push([...current]);
            return;
        }
        
        for (let i = 0; i < remaining.length; i++) {
            current.push(remaining[i]);
            backtrack(
                current,
                [...remaining.slice(0, i), ...remaining.slice(i + 1)]
            );
            current.pop();
        }
    }
    
    backtrack([], nums);
    return result;
}
```

#### 2. **Subsets**
```javascript
function subsets(nums) {
    const result = [];
    
    function backtrack(start, current) {
        result.push([...current]);
        
        for (let i = start; i < nums.length; i++) {
            current.push(nums[i]);
            backtrack(i + 1, current);
            current.pop();
        }
    }
    
    backtrack(0, []);
    return result;
}
```

**Time**: O(n!) for permutations, O(2^n) for subsets | **Space**: O(n) recursion depth

### Key Problems
- [Permutations](/topics/backtracking#permutations)
- [Subsets](/topics/backtracking#subsets)
- [N-Queens](/topics/backtracking#n-queens)
- [Generate Parentheses](/topics/stack#generate-parentheses)

---

## Greedy Algorithms

### Overview
Greedy algorithms make locally optimal choices at each step, hoping to find a global optimum. They work when local optimum leads to global optimum.

### When to Use
- Optimization problems with greedy choice property
- Activity selection problems
- Huffman coding
- Minimum spanning trees

### Key Characteristics
1. **Greedy Choice Property**: Local optimum leads to global optimum
2. **Optimal Substructure**: Optimal solution contains optimal solutions to subproblems
3. **No backtracking**: Once a choice is made, it's never reconsidered

### Common Patterns

#### 1. **Activity Selection**
```javascript
// Jump Game
function canJump(nums) {
    let maxReach = 0;
    
    for (let i = 0; i < nums.length; i++) {
        if (i > maxReach) return false;
        maxReach = Math.max(maxReach, i + nums[i]);
    }
    return true;
}
```

#### 2. **Interval Scheduling**
```javascript
// Non-overlapping Intervals
function eraseOverlapIntervals(intervals) {
    if (intervals.length === 0) return 0;
    
    // Sort by end time
    intervals.sort((a, b) => a[1] - b[1]);
    
    let count = 0;
    let end = intervals[0][1];
    
    for (let i = 1; i < intervals.length; i++) {
        if (intervals[i][0] < end) {
            count++;  // Overlapping, remove this interval
        } else {
            end = intervals[i][1];
        }
    }
    return count;
}
```

### Greedy vs DP
- **Greedy**: Makes choice without looking ahead, O(n) or O(n log n)
- **DP**: Considers all possibilities, typically O(nÂ²) or higher

### Key Problems
- [Jump Game](/topics/greedy#jump-game)
- [Jump Game II](/topics/greedy#jump-game-ii)
- [Gas Station](/topics/greedy#gas-station)
- [Maximum Subarray](/topics/greedy#maximum-subarray)

---

## Heap / Priority Queue

### Overview
A heap is a complete binary tree where each node satisfies the heap property. Min-heap: parent â‰¤ children. Max-heap: parent â‰¥ children.

### When to Use
- Finding k-th largest/smallest elements
- Merge k sorted lists
- Scheduling problems
- Median finding in stream

### Visual Pattern
```
Min Heap:
        1
       / \
      3   2
     / \ / \
    7  5 4  6

Array: [1, 3, 2, 7, 5, 4, 6]
Parent of i: (i-1)/2
Left child: 2i+1
Right child: 2i+2
```

### Common Operations
```javascript
class MinHeap {
    constructor() {
        this.heap = [];
    }
    
    push(val) {
        this.heap.push(val);
        this.bubbleUp(this.heap.length - 1);
    }
    
    pop() {
        if (this.heap.length === 0) return null;
        if (this.heap.length === 1) return this.heap.pop();
        
        const min = this.heap[0];
        this.heap[0] = this.heap.pop();
        this.bubbleDown(0);
        return min;
    }
    
    bubbleUp(index) {
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if (this.heap[parentIndex] <= this.heap[index]) break;
            
            [this.heap[parentIndex], this.heap[index]] = 
            [this.heap[index], this.heap[parentIndex]];
            index = parentIndex;
        }
    }
    
    bubbleDown(index) {
        while (true) {
            let minIndex = index;
            const leftChild = 2 * index + 1;
            const rightChild = 2 * index + 2;
            
            if (leftChild < this.heap.length && 
                this.heap[leftChild] < this.heap[minIndex]) {
                minIndex = leftChild;
            }
            
            if (rightChild < this.heap.length && 
                this.heap[rightChild] < this.heap[minIndex]) {
                minIndex = rightChild;
            }
            
            if (minIndex === index) break;
            
            [this.heap[index], this.heap[minIndex]] = 
            [this.heap[minIndex], this.heap[index]];
            index = minIndex;
        }
    }
}
```

**Time**: Insert O(log n), Delete O(log n), Peek O(1)

### Key Problems
- [Kth Largest Element](/topics/heap#kth-largest-element-in-an-array)
- [Merge k Sorted Lists](/topics/heap#merge-k-sorted-lists)
- [Find Median from Data Stream](/topics/heap#find-median-from-data-stream)
- [Top K Frequent Elements](/topics/heap#top-k-frequent-elements)

---

## Hash Table

### Overview
Hash tables store key-value pairs and provide O(1) average-case lookup, insertion, and deletion through hashing.

### When to Use
- Fast lookups by key
- Counting frequencies
- Detecting duplicates
- Caching/memoization

### Common Patterns

#### 1. **Frequency Counter**
```javascript
// Top K Frequent Elements
function topKFrequent(nums, k) {
    const freq = new Map();
    
    // Count frequencies
    for (let num of nums) {
        freq.set(num, (freq.get(num) || 0) + 1);
    }
    
    // Sort by frequency
    return [...freq.entries()]
        .sort((a, b) => b[1] - a[1])
        .slice(0, k)
        .map(([num]) => num);
}
```

#### 2. **Two Sum Pattern**
```javascript
function twoSum(nums, target) {
    const seen = new Map();
    
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        if (seen.has(complement)) {
            return [seen.get(complement), i];
        }
        seen.set(nums[i], i);
    }
    return [-1, -1];
}
```

#### 3. **Group Anagrams**
```javascript
function groupAnagrams(strs) {
    const groups = new Map();
    
    for (let str of strs) {
        const key = str.split('').sort().join('');
        if (!groups.has(key)) {
            groups.set(key, []);
        }
        groups.get(key).push(str);
    }
    
    return Array.from(groups.values());
}
```

**Time**: O(1) average for operations | **Space**: O(n)

### Key Problems
- [Two Sum](/topics/hash-table#two-sum)
- [Group Anagrams](/topics/hash-table#group-anagrams)
- [Longest Consecutive Sequence](/topics/hash-table#longest-consecutive-sequence)

---

## Stack

### Overview
A stack is a LIFO (Last In, First Out) data structure. Elements are added and removed from the same end (top).

### When to Use
- Matching parentheses/brackets
- Expression evaluation
- Backtracking problems
- Monotonic stack problems

### Common Patterns

#### 1. **Valid Parentheses**
```javascript
function isValid(s) {
    const stack = [];
    const pairs = { '(': ')', '[': ']', '{': '}' };
    
    for (let char of s) {
        if (char in pairs) {
            stack.push(char);
        } else {
            if (stack.length === 0) return false;
            const top = stack.pop();
            if (pairs[top] !== char) return false;
        }
    }
    
    return stack.length === 0;
}
```

#### 2. **Monotonic Stack**
```javascript
// Next Greater Element
function nextGreaterElement(nums) {
    const result = Array(nums.length).fill(-1);
    const stack = [];  // Stores indices
    
    for (let i = 0; i < nums.length; i++) {
        while (stack.length > 0 && nums[i] > nums[stack[stack.length - 1]]) {
            const index = stack.pop();
            result[index] = nums[i];
        }
        stack.push(i);
    }
    
    return result;
}
```

**Time**: O(n) | **Space**: O(n)

### Key Problems
- [Valid Parentheses](/topics/stack#valid-parentheses)
- [Min Stack](/topics/stack#min-stack)
- [Daily Temperatures](/topics/stack#daily-temperatures)

---

## Linked List

### Overview
A linked list is a linear data structure where elements are stored in nodes, and each node points to the next node.

### When to Use
- Dynamic size requirements
- Frequent insertions/deletions
- No random access needed
- Implementing stacks/queues

### Common Patterns

#### 1. **Reverse Linked List**
```javascript
function reverseList(head) {
    let prev = null;
    let current = head;
    
    while (current) {
        const next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    }
    
    return prev;
}
```

#### 2. **Merge Two Sorted Lists**
```javascript
function mergeTwoLists(l1, l2) {
    const dummy = new ListNode(0);
    let current = dummy;
    
    while (l1 && l2) {
        if (l1.val < l2.val) {
            current.next = l1;
            l1 = l1.next;
        } else {
            current.next = l2;
            l2 = l2.next;
        }
        current = current.next;
    }
    
    current.next = l1 || l2;
    return dummy.next;
}
```

**Time**: O(n) | **Space**: O(1)

### Key Problems
- [Reverse Linked List](/topics/linked-list#reverse-linked-list)
- [Merge Two Sorted Lists](/topics/linked-list#merge-two-sorted-lists)
- [Linked List Cycle](/topics/linked-list#linked-list-cycle)

---

## Tree Traversals

### Overview
Tree traversals visit all nodes in a tree in a specific order. Three main types: Preorder, Inorder, Postorder.

### Traversal Types

#### 1. **Preorder (Root-Left-Right)**
```javascript
function preorder(root) {
    if (!root) return [];
    return [root.val, ...preorder(root.left), ...preorder(root.right)];
}
```

#### 2. **Inorder (Left-Root-Right)**
```javascript
function inorder(root) {
    if (!root) return [];
    return [...inorder(root.left), root.val, ...inorder(root.right)];
}
```

#### 3. **Postorder (Left-Right-Root)**
```javascript
function postorder(root) {
    if (!root) return [];
    return [...postorder(root.left), ...postorder(root.right), root.val];
}
```

#### 4. **Level Order (BFS)**
```javascript
function levelOrder(root) {
    if (!root) return [];
    
    const result = [];
    const queue = [root];
    
    while (queue.length > 0) {
        const levelSize = queue.length;
        const level = [];
        
        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();
            level.push(node.val);
            
            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
        
        result.push(level);
    }
    
    return result;
}
```

### Key Problems
- [Binary Tree Inorder Traversal](/topics/tree#binary-tree-inorder-traversal)
- [Binary Tree Preorder Traversal](/topics/tree#binary-tree-preorder-traversal)
- [Binary Tree Postorder Traversal](/topics/tree#binary-tree-postorder-traversal)
- [Binary Tree Level Order Traversal](/topics/tree#binary-tree-level-order-traversal)

---

## Graph Algorithms

### Overview
Graphs consist of vertices (nodes) and edges connecting them. Can be directed or undirected, weighted or unweighted.

### Common Algorithms

#### 1. **Topological Sort (Kahn's Algorithm)**
```javascript
function topologicalSort(numCourses, prerequisites) {
    const graph = Array.from({ length: numCourses }, () => []);
    const inDegree = Array(numCourses).fill(0);
    
    // Build graph
    for (let [course, prereq] of prerequisites) {
        graph[prereq].push(course);
        inDegree[course]++;
    }
    
    // Start with nodes having no prerequisites
    const queue = [];
    for (let i = 0; i < numCourses; i++) {
        if (inDegree[i] === 0) queue.push(i);
    }
    
    const result = [];
    while (queue.length > 0) {
        const course = queue.shift();
        result.push(course);
        
        for (let next of graph[course]) {
            inDegree[next]--;
            if (inDegree[next] === 0) {
                queue.push(next);
            }
        }
    }
    
    return result.length === numCourses ? result : [];
}
```

#### 2. **Union Find (Disjoint Set)**
```javascript
class UnionFind {
    constructor(n) {
        this.parent = Array.from({ length: n }, (_, i) => i);
        this.rank = Array(n).fill(0);
    }
    
    find(x) {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]);  // Path compression
        }
        return this.parent[x];
    }
    
    union(x, y) {
        const rootX = this.find(x);
        const rootY = this.find(y);
        
        if (rootX === rootY) return false;
        
        // Union by rank
        if (this.rank[rootX] < this.rank[rootY]) {
            this.parent[rootX] = rootY;
        } else if (this.rank[rootX] > this.rank[rootY]) {
            this.parent[rootY] = rootX;
        } else {
            this.parent[rootY] = rootX;
            this.rank[rootX]++;
        }
        
        return true;
    }
}
```

### Key Problems
- [Course Schedule](/topics/graph#course-schedule)
- [Number of Islands](/topics/graph#number-of-islands)
- [Clone Graph](/topics/graph#clone-graph)
- [Graph Valid Tree](/topics/graph#graph-valid-tree)

---

## Intervals

### Overview
Interval problems involve working with ranges [start, end]. Common operations include merging, inserting, and finding overlaps.

### Common Patterns

#### 1. **Merge Intervals**
```javascript
function merge(intervals) {
    if (intervals.length === 0) return [];
    
    // Sort by start time
    intervals.sort((a, b) => a[0] - b[0]);
    
    const result = [intervals[0]];
    
    for (let i = 1; i < intervals.length; i++) {
        const current = intervals[i];
        const last = result[result.length - 1];
        
        if (current[0] <= last[1]) {
            // Overlapping, merge
            last[1] = Math.max(last[1], current[1]);
        } else {
            // Non-overlapping, add new interval
            result.push(current);
        }
    }
    
    return result;
}
```

#### 2. **Insert Interval**
```javascript
function insert(intervals, newInterval) {
    const result = [];
    let i = 0;
    
    // Add all intervals before newInterval
    while (i < intervals.length && intervals[i][1] < newInterval[0]) {
        result.push(intervals[i]);
        i++;
    }
    
    // Merge overlapping intervals
    while (i < intervals.length && intervals[i][0] <= newInterval[1]) {
        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);
        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);
        i++;
    }
    result.push(newInterval);
    
    // Add remaining intervals
    while (i < intervals.length) {
        result.push(intervals[i]);
        i++;
    }
    
    return result;
}
```

#### 3. **Meeting Rooms II (Min Rooms Needed)**
```javascript
function minMeetingRooms(intervals) {
    if (intervals.length === 0) return 0;
    
    const starts = intervals.map(i => i[0]).sort((a, b) => a - b);
    const ends = intervals.map(i => i[1]).sort((a, b) => a - b);
    
    let rooms = 0;
    let endPtr = 0;
    
    for (let i = 0; i < starts.length; i++) {
        if (starts[i] < ends[endPtr]) {
            rooms++;  // Need a new room
        } else {
            endPtr++;  // Reuse a room
        }
    }
    
    return rooms;
}
```

**Time**: O(n log n) for sorting | **Space**: O(n)

### Key Problems
- [Merge Intervals](/topics/intervals#merge-intervals)
- [Insert Interval](/topics/intervals#insert-interval)
- [Meeting Rooms II](/topics/intervals#meeting-rooms-ii)
- [Non-overlapping Intervals](/topics/intervals#non-overlapping-intervals)

---

## Summary

This guide covers the most important DSA patterns used in technical interviews. Master these patterns and you'll be able to solve most coding problems efficiently!

### Pattern Selection Strategy

1. **Array/String with contiguous elements** â†’ Sliding Window
2. **Sorted array search** â†’ Binary Search
3. **Two elements in array** â†’ Two Pointers or Hash Table
4. **Tree/Graph traversal** â†’ DFS or BFS
5. **Optimization (min/max)** â†’ Dynamic Programming or Greedy
6. **All combinations/permutations** â†’ Backtracking
7. **Top K elements** â†’ Heap
8. **Fast lookup** â†’ Hash Table
9. **LIFO operations** â†’ Stack
10. **Intervals/ranges** â†’ Intervals pattern

### Practice Resources

- [LeetCode Patterns](https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions)
- [NeetCode Roadmap](https://neetcode.io/roadmap)
- [AlgoMonster](https://algo.monster/)

Happy coding! ðŸš€