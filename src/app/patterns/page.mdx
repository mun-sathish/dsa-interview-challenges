# All DSA Patterns Guide

A comprehensive guide to all Data Structures and Algorithms patterns with detailed explanations, visualizations, and examples.

---

## Table of Contents

1. [Two Pointers](#two-pointers)
2. [Sliding Window](#sliding-window)
3. [Fast & Slow Pointers](#fast--slow-pointers)
4. [Binary Search](#binary-search)
5. [Depth-First Search (DFS)](#depth-first-search-dfs)
6. [Breadth-First Search (BFS)](#breadth-first-search-bfs)
7. [Dynamic Programming](#dynamic-programming)
8. [Backtracking](#backtracking)
9. [Greedy Algorithms](#greedy-algorithms)
10. [Heap / Priority Queue](#heap--priority-queue)
11. [Hash Table](#hash-table)
12. [Stack](#stack)
13. [Linked List](#linked-list)
14. [Tree Traversals](#tree-traversals)
15. [Graph Algorithms](#graph-algorithms)
16. [Intervals](#intervals)

---

## Two Pointers

### Overview
The Two Pointers pattern uses two pointers to iterate through a data structure, typically an array or linked list. The pointers can move toward each other, away from each other, or at different speeds.

### When to Use
- Searching pairs in a sorted array
- Removing duplicates from sorted arrays
- Comparing elements from both ends
- Finding subarrays or subsequences

### Visual Pattern
```
Opposite Direction:
[1, 2, 3, 4, 5, 6]
 ↑              ↑
 left          right

Same Direction:
[1, 2, 3, 4, 5, 6]
 ↑  ↑
slow fast
```

### Common Variations

#### 1. **Opposite Direction (Converging)**

**Example Problems:**
- Two Sum II - Sorted Array - Find two numbers that add up to target
- [3Sum](/topics/two-pointers#3sum) - Find all unique triplets that sum to zero
- [Container With Most Water](/topics/two-pointers#container-with-most-water) - Find max area between two lines

```javascript
// Example 1: Two Sum II - Sorted Array
function twoSum(numbers, target) {
    let left = 0;
    let right = numbers.length - 1;
    
    while (left < right) {
        const sum = numbers[left] + numbers[right];
        if (sum === target) return [left + 1, right + 1];
        if (sum < target) left++;
        else right--;
    }
    return [-1, -1];
}

// Example 2: Container With Most Water
function maxArea(height) {
    let left = 0;
    let right = height.length - 1;
    let maxArea = 0;
    
    while (left < right) {
        const width = right - left;
        const minHeight = Math.min(height[left], height[right]);
        maxArea = Math.max(maxArea, width * minHeight);
        
        // Move pointer with smaller height
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }
    
    return maxArea;
}
```

**Time**: O(n) | **Space**: O(1)

#### 2. **Same Direction (Fast & Slow)**

**Example Problems:**
- Remove Duplicates from Sorted Array - Remove duplicates in-place
- Move Zeroes - Move all zeros to end while maintaining order
- Remove Element - Remove all instances of a value in-place

```javascript
// Example 1: Remove Duplicates from Sorted Array
function removeDuplicates(nums) {
    let slow = 0;
    
    for (let fast = 1; fast < nums.length; fast++) {
        if (nums[fast] !== nums[slow]) {
            slow++;
            nums[slow] = nums[fast];
        }
    }
    return slow + 1;
}

// Example 2: Move Zeroes
function moveZeroes(nums) {
    let slow = 0;  // Position for next non-zero
    
    for (let fast = 0; fast < nums.length; fast++) {
        if (nums[fast] !== 0) {
            [nums[slow], nums[fast]] = [nums[fast], nums[slow]];
            slow++;
        }
    }
}
```

**Time**: O(n) | **Space**: O(1)

### Key Problems
- [Two Sum](/topics/hash-table#two-sum)
- [3Sum](/topics/two-pointers#3sum)
- [Container With Most Water](/topics/two-pointers#container-with-most-water)

---

## Sliding Window

### Overview
The Sliding Window pattern maintains a window (subarray) that slides through the array/string to find optimal solutions. The window can be fixed-size or variable-size.

### When to Use
- Finding subarrays/substrings with specific properties
- Maximum/minimum subarray problems
- String pattern matching
- Consecutive elements problems

### Visual Pattern
```
Fixed Window (size=3):
[1, 2, 3, 4, 5, 6]
 [-----]           window at position 0
    [-----]        window slides right
       [-----]     window slides right

Variable Window:
[1, 2, 3, 4, 5]
 [---]            expand when condition not met
 [-------]        contract when condition met
```

### Common Variations

#### 1. **Fixed Window Size**

**Example Problems:**
- Maximum Sum Subarray of Size K - Find max sum of k consecutive elements
- Maximum Average Subarray - Find subarray with maximum average
- Find All Anagrams in String - Find all anagram occurrences in string

```javascript
// Example 1: Maximum Sum Subarray of Size K
function maxSumSubarray(arr, k) {
    let maxSum = 0;
    let windowSum = 0;
    
    // Calculate first window
    for (let i = 0; i < k; i++) {
        windowSum += arr[i];
    }
    maxSum = windowSum;
    
    // Slide window
    for (let i = k; i < arr.length; i++) {
        windowSum = windowSum - arr[i - k] + arr[i];
        maxSum = Math.max(maxSum, windowSum);
    }
    return maxSum;
}

// Example 2: Find All Anagrams in String
function findAnagrams(s, p) {
    const result = [];
    if (s.length < p.length) return result;
    
    const pCount = {};
    const windowCount = {};
    
    // Count characters in p
    for (let char of p) {
        pCount[char] = (pCount[char] || 0) + 1;
    }
    
    // Initial window
    for (let i = 0; i < p.length; i++) {
        windowCount[s[i]] = (windowCount[s[i]] || 0) + 1;
    }
    
    // Helper to compare objects
    const isEqual = (obj1, obj2) => {
        const keys1 = Object.keys(obj1);
        const keys2 = Object.keys(obj2);
        if (keys1.length !== keys2.length) return false;
        return keys1.every(key => obj1[key] === obj2[key]);
    };
    
    if (isEqual(pCount, windowCount)) result.push(0);
    
    // Slide window
    for (let i = p.length; i < s.length; i++) {
        windowCount[s[i]] = (windowCount[s[i]] || 0) + 1;
        
        const oldChar = s[i - p.length];
        windowCount[oldChar]--;
        if (windowCount[oldChar] === 0) delete windowCount[oldChar];
        
        if (isEqual(pCount, windowCount)) {
            result.push(i - p.length + 1);
        }
    }
    
    return result;
}
```

**Time**: O(n) | **Space**: O(1)

#### 2. **Variable Window Size**

**Example Problems:**
- [Longest Substring Without Repeating Characters](/topics/sliding-window#longest-substring-without-repeating-characters) - Find longest substring without repeats
- [Minimum Window Substring](/topics/sliding-window#minimum-window-substring) - Find smallest window containing all characters
- [Longest Repeating Character Replacement](/topics/sliding-window#longest-repeating-character-replacement) - Longest substring after k replacements

```javascript
// Example 1: Longest Substring Without Repeating Characters
function lengthOfLongestSubstring(s) {
    const seen = new Set();
    let left = 0;
    let maxLen = 0;
    
    for (let right = 0; right < s.length; right++) {
        while (seen.has(s[right])) {
            seen.delete(s[left]);
            left++;
        }
        seen.add(s[right]);
        maxLen = Math.max(maxLen, right - left + 1);
    }
    return maxLen;
}

// Example 2: Longest Repeating Character Replacement
function characterReplacement(s, k) {
    const count = {};
    let left = 0;
    let maxCount = 0;
    let maxLen = 0;
    
    for (let right = 0; right < s.length; right++) {
        count[s[right]] = (count[s[right]] || 0) + 1;
        maxCount = Math.max(maxCount, count[s[right]]);
        
        // If window size - max frequency > k, shrink window
        while (right - left + 1 - maxCount > k) {
            count[s[left]]--;
            left++;
        }
        
        maxLen = Math.max(maxLen, right - left + 1);
    }
    
    return maxLen;
}
```

**Time**: O(n) | **Space**: O(min(n, m)) where m is charset size

### Template
```javascript
function slidingWindow(arr) {
    let left = 0;
    let result = 0;
    
    for (let right = 0; right < arr.length; right++) {
        // Expand window: add arr[right] to window
        
        while (/* window condition violated */) {
            // Contract window: remove arr[left] from window
            left++;
        }
        
        // Update result
        result = Math.max(result, right - left + 1);
    }
    return result;
}
```

### Key Problems
- [Longest Substring Without Repeating Characters](/topics/sliding-window#longest-substring-without-repeating-characters)
- [Minimum Window Substring](/topics/sliding-window#minimum-window-substring)
- [Longest Repeating Character Replacement](/topics/sliding-window#longest-repeating-character-replacement)

---

## Fast & Slow Pointers

### Overview
Also known as the "Tortoise and Hare" algorithm, this pattern uses two pointers moving at different speeds to detect cycles or find middle elements.

### When to Use
- Detecting cycles in linked lists
- Finding middle of linked list
- Detecting palindromes
- Finding cycle start point

### Visual Pattern
```
Cycle Detection:
1 → 2 → 3 → 4 → 5
         ↑       ↓
         8 ← 7 ← 6

slow: 1 → 2 → 3 → 4 → 5 → 6 → 7 → 8 → 3...
fast: 1 → 3 → 5 → 7 → 3 → 7 → 3...
      They meet at some point in cycle!
```

### Implementation
```javascript
// Detect Cycle in Linked List
function hasCycle(head) {
    let slow = head;
    let fast = head;
    
    while (fast && fast.next) {
        slow = slow.next;           // Move 1 step
        fast = fast.next.next;      // Move 2 steps
        
        if (slow === fast) {
            return true;  // Cycle detected
        }
    }
    return false;  // No cycle
}

// Find Middle of Linked List
function findMiddle(head) {
    let slow = head;
    let fast = head;
    
    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;  // Middle node
}
```

**Time**: O(n) | **Space**: O(1)

### Key Problems
- [Linked List Cycle](/topics/linked-list#linked-list-cycle)
- [Happy Number](/topics/hash-table#happy-number)
- [Find Duplicate Number](/topics/array#find-duplicate-number)

---

## Binary Search

### Overview
Binary Search is a divide-and-conquer algorithm that efficiently finds a target value in a sorted array by repeatedly dividing the search interval in half.

### When to Use
- Searching in sorted arrays
- Finding boundaries (first/last occurrence)
- Optimization problems (minimize/maximize)
- Search in rotated sorted arrays

### Visual Pattern
```
Array: [1, 3, 5, 7, 9, 11, 13, 15]
Target: 7

Step 1: [1, 3, 5, 7, 9, 11, 13, 15]
         L        M              R
         mid = 9 > 7, search left

Step 2: [1, 3, 5, 7]
         L     M  R
         mid = 5 < 7, search right

Step 3: [7]
         L/M/R
         Found!
```

### Templates

#### 1. **Standard Binary Search**

**Example Problems:**
- [Binary Search](/topics/binary-search#binary-search) - Find target in sorted array
- Search Insert Position - Find index where target should be inserted
- Find First and Last Position - Find start and end of target range

```javascript
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
        const mid = left + Math.floor((right - left) / 2);
        
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}
```

**Time**: O(log n) | **Space**: O(1)

#### 2. **Modified Binary Search (Search Space Reduction)**

**Example Problems:**
- [Search in Rotated Sorted Array](/topics/binary-search#search-in-rotated-sorted-array) - Search in rotated array
- [Find Minimum in Rotated Sorted Array](/topics/binary-search#find-minimum-in-rotated-sorted-array) - Find minimum in rotated array
- Find Peak Element - Find any peak element in array

```javascript
// Example: Find Peak Element
function findPeakElement(nums) {
    let left = 0;
    let right = nums.length - 1;
    
    while (left < right) {
        const mid = left + Math.floor((right - left) / 2);
        
        if (nums[mid] > nums[mid + 1]) {
            // Peak is on left side (including mid)
            right = mid;
        } else {
            // Peak is on right side
            left = mid + 1;
        }
    }
    
    return left;
}
```

Modified binary search applies the binary search principle to problems where the search space isn't explicitly an array. The key insight is identifying a monotonic property that allows elimination of half the search space.

**Common Use Cases:**
- Finding minimum/maximum in rotated sorted arrays
- Search in 2D matrices
- Finding peak elements
- Optimization problems (minimize/maximize a value)
- Finding square roots, nth roots
- Capacity/allocation problems

**Template for Modified Binary Search:**
```javascript
function modifiedBinarySearch(searchSpace) {
    let left = minValue;
    let right = maxValue;
    
    while (left < right) {
        const mid = left + Math.floor((right - left) / 2);
        
        if (isValid(mid)) {
            // If mid satisfies condition, search left half
            right = mid;
        } else {
            // Otherwise, search right half
            left = mid + 1;
        }
    }
    
    return left;  // or right, they're equal
}
```

**Example: Find Minimum in Rotated Sorted Array**
```javascript
function findMin(nums) {
    let left = 0;
    let right = nums.length - 1;
    
    while (left < right) {
        const mid = left + Math.floor((right - left) / 2);
        
        // If mid element is greater than rightmost element,
        // minimum must be in right half
        if (nums[mid] > nums[right]) {
            left = mid + 1;
        } else {
            // Otherwise, minimum is in left half (including mid)
            right = mid;
        }
    }
    
    return nums[left];
}
```

**Example: Search in Rotated Sorted Array**
```javascript
function search(nums, target) {
    let left = 0;
    let right = nums.length - 1;
    
    while (left <= right) {
        const mid = left + Math.floor((right - left) / 2);
        
        if (nums[mid] === target) return mid;
        
        // Determine which half is sorted
        if (nums[left] <= nums[mid]) {
            // Left half is sorted
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            // Right half is sorted
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    
    return -1;
}
```

**Key Insight**: Modified binary search works when you can define a condition that divides the search space into two parts where one part definitely doesn't contain the answer.

### Key Problems
- [Binary Search](/topics/binary-search#binary-search)
- [Search in Rotated Sorted Array](/topics/binary-search#search-in-rotated-sorted-array)
- [Find Minimum in Rotated Sorted Array](/topics/binary-search#find-minimum-in-rotated-sorted-array)

---

## Depth-First Search (DFS)

### Overview
DFS explores as far as possible along each branch before backtracking. It uses a stack (or recursion) to keep track of nodes to visit.

### When to Use
- Tree/graph traversal
- Finding paths
- Detecting cycles
- Topological sorting
- Connected components

### Visual Pattern
```
Tree DFS Traversal:
        1
       / \
      2   3
     / \
    4   5

Preorder (Root-Left-Right):  1 → 2 → 4 → 5 → 3
Inorder (Left-Root-Right):   4 → 2 → 5 → 1 → 3
Postorder (Left-Right-Root): 4 → 5 → 2 → 3 → 1
```

### Tree Traversal Types

#### 1. **Preorder Traversal (Root-Left-Right)**

**When to Use:**
- Creating a copy of the tree
- Getting prefix expression of an expression tree
- Serializing a tree structure
- Tree construction problems

**Example Problems:**
- [Binary Tree Preorder Traversal](/topics/tree#binary-tree-preorder-traversal) - Basic traversal implementation
- Serialize and Deserialize Binary Tree - Convert tree to string representation
- Flatten Binary Tree to Linked List - Restructure tree using preorder sequence
- Path Sum - Check if root-to-leaf path exists with given sum

**Example Solutions:**
```javascript
// Example 1: Path Sum
function hasPathSum(root, targetSum) {
    if (!root) return false;
    
    // Leaf node - check if path sum equals target
    if (!root.left && !root.right) {
        return root.val === targetSum;
    }
    
    // Recurse on children with reduced target
    return hasPathSum(root.left, targetSum - root.val) ||
           hasPathSum(root.right, targetSum - root.val);
}

// Example 2: Flatten Binary Tree to Linked List
function flatten(root) {
    if (!root) return;
    
    // Flatten left and right subtrees
    flatten(root.left);
    flatten(root.right);
    
    // Store right subtree
    const rightSubtree = root.right;
    
    // Move left subtree to right
    root.right = root.left;
    root.left = null;
    
    // Attach original right subtree to end
    let current = root;
    while (current.right) {
        current = current.right;
    }
    current.right = rightSubtree;
}
```

**Basic Preorder Traversal:**
```javascript
function preorderTraversal(root) {
    const result = [];
    
    function traverse(node) {
        if (!node) return;
        
        result.push(node.val);      // Process root first
        traverse(node.left);         // Then left subtree
        traverse(node.right);        // Then right subtree
    }
    
    traverse(root);
    return result;
}
```

**Iterative Implementation:**
```javascript
function preorderIterative(root) {
    if (!root) return [];
    
    const result = [];
    const stack = [root];
    
    while (stack.length > 0) {
        const node = stack.pop();
        result.push(node.val);
        
        // Push right first so left is processed first
        if (node.right) stack.push(node.right);
        if (node.left) stack.push(node.left);
    }
    
    return result;
}
```

#### 2. **Inorder Traversal (Left-Root-Right)**

**When to Use:**
- Getting values in sorted order from BST
- Validating BST
- Finding kth smallest/largest in BST
- Converting BST to sorted array

**Example Problems:**
- [Binary Tree Inorder Traversal](/topics/tree#binary-tree-inorder-traversal) - Basic traversal implementation
- Validate Binary Search Tree - Check if tree is valid BST using inorder
- Kth Smallest Element in BST - Find kth smallest using inorder traversal
- Binary Tree Inorder Successor - Find next node in inorder sequence
- Recover Binary Search Tree - Fix swapped nodes using inorder property

**Recursive Implementation:**
```javascript
// Example: Validate Binary Search Tree
function isValidBST(root) {
    function validate(node, min, max) {
        if (!node) return true;
        
        if (node.val <= min || node.val >= max) {
            return false;
        }
        
        return validate(node.left, min, node.val) &&
               validate(node.right, node.val, max);
    }
    
    return validate(root, -Infinity, Infinity);
}

// Example: Kth Smallest Element in BST
function kthSmallest(root, k) {
    let count = 0;
    let result = null;
    
    function inorder(node) {
        if (!node || result !== null) return;
        
        inorder(node.left);
        count++;
        if (count === k) {
            result = node.val;
            return;
        }
        inorder(node.right);
    }
    
    inorder(root);
    return result;
}
```

**Basic Inorder Traversal:**
```javascript
function inorderTraversal(root) {
    const result = [];
    
    function traverse(node) {
        if (!node) return;
        
        traverse(node.left);         // Process left subtree first
        result.push(node.val);       // Then root
        traverse(node.right);        // Then right subtree
    }
    
    traverse(root);
    return result;
}
```

**Iterative Implementation:**
```javascript
function inorderIterative(root) {
    const result = [];
    const stack = [];
    let current = root;
    
    while (current || stack.length > 0) {
        // Go to leftmost node
        while (current) {
            stack.push(current);
            current = current.left;
        }
        
        // Process node
        current = stack.pop();
        result.push(current.val);
        
        // Move to right subtree
        current = current.right;
    }
    
    return result;
}
```

**Key Property**: For BST, inorder traversal gives nodes in ascending order!

#### 3. **Postorder Traversal (Left-Right-Root)**

**When to Use:**
- Deleting a tree (delete children before parent)
- Getting postfix expression of an expression tree
- Bottom-up calculations (height, diameter)
- Dependency resolution

**Example Problems:**
- [Binary Tree Postorder Traversal](/topics/tree#binary-tree-postorder-traversal) - Basic traversal implementation
- Maximum Depth of Binary Tree - Calculate height using postorder
- Diameter of Binary Tree - Find longest path using postorder
- Lowest Common Ancestor - Find LCA using postorder traversal
- Binary Tree Maximum Path Sum - Calculate max path using postorder
- Delete Nodes and Return Forest - Delete nodes and return remaining trees

**Recursive Implementation:**
```javascript
// Example: Maximum Depth of Binary Tree
function maxDepth(root) {
    if (!root) return 0;
    
    const leftDepth = maxDepth(root.left);
    const rightDepth = maxDepth(root.right);
    
    return Math.max(leftDepth, rightDepth) + 1;
}

// Example: Diameter of Binary Tree
function diameterOfBinaryTree(root) {
    let diameter = 0;
    
    function height(node) {
        if (!node) return 0;
        
        const leftHeight = height(node.left);
        const rightHeight = height(node.right);
        
        // Update diameter at this node
        diameter = Math.max(diameter, leftHeight + rightHeight);
        
        return Math.max(leftHeight, rightHeight) + 1;
    }
    
    height(root);
    return diameter;
}
```

**Basic Postorder Traversal:**
```javascript
function postorderTraversal(root) {
    const result = [];
    
    function traverse(node) {
        if (!node) return;
        
        traverse(node.left);         // Process left subtree first
        traverse(node.right);        // Then right subtree
        result.push(node.val);       // Then root (after children)
    }
    
    traverse(root);
    return result;
}
```

**Iterative Implementation:**
```javascript
function postorderIterative(root) {
    if (!root) return [];
    
    const result = [];
    const stack = [root];
    
    while (stack.length > 0) {
        const node = stack.pop();
        result.unshift(node.val);  // Add to front
        
        // Push left first so right is processed first
        if (node.left) stack.push(node.left);
        if (node.right) stack.push(node.right);
    }
    
    return result;
}
```

### Graph DFS Implementation

```javascript
// Graph DFS (for connected components, cycle detection, etc.)
function dfsGraph(graph, start, visited = new Set()) {
    visited.add(start);
    console.log(start);
    
    for (let neighbor of graph[start]) {
        if (!visited.has(neighbor)) {
            dfsGraph(graph, neighbor, visited);
        }
    }
}
```

### Traversal Comparison

| Traversal | Order | Best For | Example Problems |
|-----------|-------|----------|------------------|
| **Preorder** | Root → Left → Right | Tree copying, serialization | Flatten tree, serialize tree |
| **Inorder** | Left → Root → Right | BST operations, sorted output | Validate BST, kth smallest |
| **Postorder** | Left → Right → Root | Tree deletion, bottom-up calc | Tree height, LCA, delete nodes |

**Time**: O(V + E) for graphs, O(n) for trees | **Space**: O(h) where h is height

### Key Problems
- [Number of Islands](/topics/graph#number-of-islands)
- [Clone Graph](/topics/graph#clone-graph)
- [All Paths From Source to Target](/topics/graph#all-paths-from-source-to-target)

---

## Breadth-First Search (BFS)

### Overview
BFS explores all nodes at the current depth before moving to nodes at the next depth level. It uses a queue to keep track of nodes to visit.

### When to Use
- Shortest path in unweighted graphs
- Level-order traversal
- Finding nearest neighbors
- Minimum steps problems

### Visual Pattern
```
Tree BFS (Level Order):
        1
       / \
      2   3
     / \   \
    4   5   6

Level 0: [1]
Level 1: [2, 3]
Level 2: [4, 5, 6]

Queue evolution:
[1] → [2,3] → [3,4,5] → [4,5,6] → [5,6] → [6] → []
```

### Implementations

#### 1. **Standard BFS**

**Example Problems:**
- [Binary Tree Level Order Traversal](/topics/tree#binary-tree-level-order-traversal) - Traverse tree level by level
- Binary Tree Right Side View - View tree from right side
- Binary Tree Zigzag Level Order - Zigzag level order traversal

```javascript
function bfs(root) {
    if (!root) return;
    
    const queue = [root];
    
    while (queue.length > 0) {
        const node = queue.shift();
        console.log(node.val);
        
        if (node.left) queue.push(node.left);
        if (node.right) queue.push(node.right);
    }
}
```

#### 2. **Level-Order BFS**

**Example Problems:**
- [Rotting Oranges](/topics/graph#rotting-oranges) - Find time for all oranges to rot
- Shortest Path in Binary Matrix - Find shortest path in grid
- Word Ladder - Find shortest transformation sequence

```javascript
function levelOrder(root) {
    if (!root) return [];
    
    const result = [];
    const queue = [root];
    
    while (queue.length > 0) {
        const levelSize = queue.length;
        const currentLevel = [];
        
        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();
            currentLevel.push(node.val);
            
            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
        
        result.push(currentLevel);
    }
    return result;
}
```

**Time**: O(V + E) for graphs, O(n) for trees | **Space**: O(w) where w is max width

### Key Problems
- [Binary Tree Level Order Traversal](/topics/tree#binary-tree-level-order-traversal)
- [Rotting Oranges](/topics/graph#rotting-oranges)
- [Word Ladder](/topics/graph#word-ladder)

---

## Dynamic Programming

### Overview
Dynamic Programming solves complex problems by breaking them down into simpler subproblems and storing their solutions to avoid redundant calculations.

### When to Use
- Optimization problems (min/max)
- Counting problems
- Problems with overlapping subproblems
- Problems with optimal substructure

### Core Concepts

#### 1. **Memoization (Top-Down)**

**Example Problems:**
- [Climbing Stairs](/topics/dynamic-programming#climbing-stairs) - Count ways to climb stairs
- Decode Ways - Count ways to decode a message
- Word Break - Check if string can be segmented

```javascript
// Example 1: Fibonacci with Memoization
function fib(n, memo = {}) {
    if (n <= 1) return n;
    if (memo[n]) return memo[n];
    
    memo[n] = fib(n - 1, memo) + fib(n - 2, memo);
    return memo[n];
}

// Example 2: Climbing Stairs
function climbStairs(n, memo = {}) {
    if (n <= 2) return n;
    if (memo[n]) return memo[n];
    
    memo[n] = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);
    return memo[n];
}
```

#### 2. **Tabulation (Bottom-Up)**

**Example Problems:**
- House Robber - Maximum money without robbing adjacent houses
- Best Time to Buy and Sell Stock - Maximum profit from stock transactions
- Maximum Product Subarray - Find subarray with maximum product

```javascript
// Fibonacci with Tabulation
function fib(n) {
    if (n <= 1) return n;
    
    const dp = [0, 1];
    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

### Common DP Patterns

#### 1. **Linear DP (1D)**

**Example Problems:**
- House Robber - Rob houses to maximize money
- [Coin Change](/topics/dynamic-programming#coin-change) - Minimum coins for amount
- Longest Increasing Subsequence - Find LIS length

```javascript
// House Robber
function rob(nums) {
    if (nums.length === 0) return 0;
    if (nums.length === 1) return nums[0];
    
    const dp = [nums[0], Math.max(nums[0], nums[1])];
    
    for (let i = 2; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
    }
    return dp[nums.length - 1];
}
```

**Pattern**: `dp[i] = f(dp[i-1], dp[i-2], ...)`

#### 2. **Grid DP (2D)**

**Example Problems:**
- Unique Paths - Count paths in grid
- Minimum Path Sum - Find path with minimum sum
- Edit Distance - Minimum operations to convert strings

```javascript
// Unique Paths
function uniquePaths(m, n) {
    const dp = Array(m).fill().map(() => Array(n).fill(1));
    
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}
```

**Pattern**: `dp[i][j] = f(dp[i-1][j], dp[i][j-1], ...)`

#### 3. **Knapsack DP**

**Example Problems:**
- Partition Equal Subset Sum - Check if array can be partitioned
- Target Sum - Count ways to reach target sum
- Ones and Zeroes - Maximum subset with m zeros and n ones

```javascript
// 0/1 Knapsack
function knapsack(weights, values, capacity) {
    const n = weights.length;
    const dp = Array(n + 1).fill().map(() => Array(capacity + 1).fill(0));
    
    for (let i = 1; i <= n; i++) {
        for (let w = 1; w <= capacity; w++) {
            if (weights[i - 1] <= w) {
                dp[i][w] = Math.max(
                    dp[i - 1][w],
                    dp[i - 1][w - weights[i - 1]] + values[i - 1]
                );
            } else {
                dp[i][w] = dp[i - 1][w];
            }
        }
    }
    return dp[n][capacity];
}
```

### DP Problem-Solving Steps
1. **Define the state**: What does `dp[i]` or `dp[i][j]` represent?
2. **Find the recurrence relation**: How to compute current state from previous states?
3. **Initialize base cases**: What are the starting values?
4. **Determine iteration order**: Bottom-up or top-down?
5. **Optimize space**: Can we reduce dimensions?

### Key Problems
- [Climbing Stairs](/topics/dynamic-programming#climbing-stairs)
- [Coin Change](/topics/dynamic-programming#coin-change)
- [Longest Increasing Subsequence](/topics/dynamic-programming#longest-increasing-subsequence)
- [Longest Common Subsequence](/topics/dynamic-programming#longest-common-subsequence)

---

## Backtracking

### Overview
Backtracking builds solutions incrementally and abandons solutions that fail to satisfy constraints. It's essentially DFS with pruning.

### When to Use
- Generating all combinations/permutations
- Solving constraint satisfaction problems
- Finding all solutions to a problem
- Puzzles (N-Queens, Sudoku)

### Visual Pattern
```
Generate Permutations of [1,2,3]:

                    []
           /         |         \
         [1]        [2]        [3]
        /   \      /   \      /   \
     [1,2] [1,3] [2,1] [2,3] [3,1] [3,2]
       |     |     |     |     |     |
    [1,2,3][1,3,2][2,1,3][2,3,1][3,1,2][3,2,1]
```

### Template
```javascript
function backtrack(result, current, choices) {
    // Base case: solution found
    if (isComplete(current)) {
        result.push([...current]);
        return;
    }
    
    // Try each choice
    for (let choice of choices) {
        // Make choice
        current.push(choice);
        
        // Recurse
        backtrack(result, current, getNextChoices(choices, choice));
        
        // Undo choice (backtrack)
        current.pop();
    }
}
```

### Common Patterns

#### 1. **Permutations**

**Example Problems:**
- [Permutations](/topics/backtracking#permutations) - Generate all permutations
- Permutations II - Generate unique permutations with duplicates
- Letter Case Permutation - Generate all letter case combinations

```javascript
// Example 1: Permutations
function permute(nums) {
    const result = [];
    
    function backtrack(current, remaining) {
        if (remaining.length === 0) {
            result.push([...current]);
            return;
        }
        
        for (let i = 0; i < remaining.length; i++) {
            current.push(remaining[i]);
            backtrack(
                current,
                [...remaining.slice(0, i), ...remaining.slice(i + 1)]
            );
            current.pop();
        }
    }
    
    backtrack([], nums);
    return result;
}

// Example 2: Letter Case Permutation
function letterCasePermutation(s) {
    const result = [];
    
    function backtrack(index, current) {
        if (index === s.length) {
            result.push(current);
            return;
        }
        
        const char = s[index];
        if (isNaN(char)) {
            // Letter: try both cases
            backtrack(index + 1, current + char.toLowerCase());
            backtrack(index + 1, current + char.toUpperCase());
        } else {
            // Digit: keep as is
            backtrack(index + 1, current + char);
        }
    }
    
    backtrack(0, '');
    return result;
}
```

#### 2. **Subsets**

**Example Problems:**
- [Subsets](/topics/backtracking#subsets) - Generate all subsets
- Subsets II - Generate unique subsets with duplicates
- Combination Sum - Find combinations that sum to target

```javascript
function subsets(nums) {
    const result = [];
    
    function backtrack(start, current) {
        result.push([...current]);
        
        for (let i = start; i < nums.length; i++) {
            current.push(nums[i]);
            backtrack(i + 1, current);
            current.pop();
        }
    }
    
    backtrack(0, []);
    return result;
}
```

**Time**: O(n!) for permutations, O(2^n) for subsets | **Space**: O(n) recursion depth

### Key Problems
- [Permutations](/topics/backtracking#permutations)
- [Subsets](/topics/backtracking#subsets)
- [N-Queens](/topics/backtracking#n-queens)
- [Generate Parentheses](/topics/stack#generate-parentheses)

---

## Greedy Algorithms

### Overview
Greedy algorithms make locally optimal choices at each step, hoping to find a global optimum. They work when local optimum leads to global optimum.

### When to Use
- Optimization problems with greedy choice property
- Activity selection problems
- Huffman coding
- Minimum spanning trees

### Key Characteristics
1. **Greedy Choice Property**: Local optimum leads to global optimum
2. **Optimal Substructure**: Optimal solution contains optimal solutions to subproblems
3. **No backtracking**: Once a choice is made, it's never reconsidered

### Common Patterns

#### 1. **Activity Selection**

**Example Problems:**
- [Jump Game](/topics/greedy#jump-game) - Check if can reach last index
- [Jump Game II](/topics/greedy#jump-game-ii) - Minimum jumps to reach end
- Meeting Rooms - Check if person can attend all meetings

```javascript
// Example 1: Jump Game
function canJump(nums) {
    let maxReach = 0;
    
    for (let i = 0; i < nums.length; i++) {
        if (i > maxReach) return false;
        maxReach = Math.max(maxReach, i + nums[i]);
    }
    return true;
}

// Example 2: Jump Game II
function jump(nums) {
    let jumps = 0;
    let currentEnd = 0;
    let farthest = 0;
    
    for (let i = 0; i < nums.length - 1; i++) {
        farthest = Math.max(farthest, i + nums[i]);
        
        if (i === currentEnd) {
            jumps++;
            currentEnd = farthest;
        }
    }
    
    return jumps;
}

// Example 3: Meeting Rooms
function canAttendMeetings(intervals) {
    if (intervals.length === 0) return true;
    
    // Sort by start time
    intervals.sort((a, b) => a[0] - b[0]);
    
    for (let i = 1; i < intervals.length; i++) {
        if (intervals[i][0] < intervals[i - 1][1]) {
            return false;  // Overlap found
        }
    }
    
    return true;
}
```

#### 2. **Interval Scheduling**

**Example Problems:**
- Non-overlapping Intervals - Minimum intervals to remove
- Minimum Number of Arrows - Minimum arrows to burst balloons
- [Gas Station](/topics/greedy#gas-station) - Find starting gas station

```javascript
// Example 1: Non-overlapping Intervals
function eraseOverlapIntervals(intervals) {
    if (intervals.length === 0) return 0;
    
    // Sort by end time
    intervals.sort((a, b) => a[1] - b[1]);
    
    let count = 0;
    let end = intervals[0][1];
    
    for (let i = 1; i < intervals.length; i++) {
        if (intervals[i][0] < end) {
            count++;  // Overlapping, remove this interval
        } else {
            end = intervals[i][1];
        }
    }
    return count;
}

// Example 2: Minimum Number of Arrows to Burst Balloons
function findMinArrowShots(points) {
    if (points.length === 0) return 0;
    
    // Sort by end position
    points.sort((a, b) => a[1] - b[1]);
    
    let arrows = 1;
    let end = points[0][1];
    
    for (let i = 1; i < points.length; i++) {
        if (points[i][0] > end) {
            // Need new arrow
            arrows++;
            end = points[i][1];
        }
    }
    
    return arrows;
}
```

### Greedy vs DP
- **Greedy**: Makes choice without looking ahead, O(n) or O(n log n)
- **DP**: Considers all possibilities, typically O(n²) or higher

### Key Problems
- [Jump Game](/topics/greedy#jump-game)
- [Jump Game II](/topics/greedy#jump-game-ii)
- [Gas Station](/topics/greedy#gas-station)
- [Maximum Subarray](/topics/greedy#maximum-subarray)

---

## Heap / Priority Queue

### Overview
A heap is a complete binary tree where each node satisfies the heap property. Min-heap: parent ≤ children. Max-heap: parent ≥ children.

### When to Use
- Finding k-th largest/smallest elements
- Merge k sorted lists
- Scheduling problems
- Median finding in stream

### Visual Pattern
```
Min Heap:
        1
       / \
      3   2
     / \ / \
    7  5 4  6

Array: [1, 3, 2, 7, 5, 4, 6]
Parent of i: (i-1)/2
Left child: 2i+1
Right child: 2i+2
```

### Common Operations
```javascript
class MinHeap {
    constructor() {
        this.heap = [];
    }
    
    push(val) {
        this.heap.push(val);
        this.bubbleUp(this.heap.length - 1);
    }
    
    pop() {
        if (this.heap.length === 0) return null;
        if (this.heap.length === 1) return this.heap.pop();
        
        const min = this.heap[0];
        this.heap[0] = this.heap.pop();
        this.bubbleDown(0);
        return min;
    }
    
    bubbleUp(index) {
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if (this.heap[parentIndex] <= this.heap[index]) break;
            
            [this.heap[parentIndex], this.heap[index]] = 
            [this.heap[index], this.heap[parentIndex]];
            index = parentIndex;
        }
    }
    
    bubbleDown(index) {
        while (true) {
            let minIndex = index;
            const leftChild = 2 * index + 1;
            const rightChild = 2 * index + 2;
            
            if (leftChild < this.heap.length && 
                this.heap[leftChild] < this.heap[minIndex]) {
                minIndex = leftChild;
            }
            
            if (rightChild < this.heap.length && 
                this.heap[rightChild] < this.heap[minIndex]) {
                minIndex = rightChild;
            }
            
            if (minIndex === index) break;
            
            [this.heap[index], this.heap[minIndex]] = 
            [this.heap[minIndex], this.heap[index]];
            index = minIndex;
        }
    }
}
```

**Time**: Insert O(log n), Delete O(log n), Peek O(1)

### Key Problems
- [Kth Largest Element](/topics/heap#kth-largest-element-in-an-array)
- [Merge k Sorted Lists](/topics/heap#merge-k-sorted-lists)
- [Find Median from Data Stream](/topics/heap#find-median-from-data-stream)
- [Top K Frequent Elements](/topics/heap#top-k-frequent-elements)

---

## Hash Table

### Overview
Hash tables store key-value pairs and provide O(1) average-case lookup, insertion, and deletion through hashing.

### When to Use
- Fast lookups by key
- Counting frequencies
- Detecting duplicates
- Caching/memoization

### Common Patterns

#### 1. **Frequency Counter**

**Example Problems:**
- [Top K Frequent Elements](/topics/heap#top-k-frequent-elements) - Find k most frequent elements
- Valid Anagram - Check if two strings are anagrams
- First Unique Character - Find first non-repeating character

```javascript
// Example 1: Top K Frequent Elements
function topKFrequent(nums, k) {
    const freq = new Map();
    
    // Count frequencies
    for (let num of nums) {
        freq.set(num, (freq.get(num) || 0) + 1);
    }
    
    // Sort by frequency
    return [...freq.entries()]
        .sort((a, b) => b[1] - a[1])
        .slice(0, k)
        .map(([num]) => num);
}

// Example 2: Valid Anagram
function isAnagram(s, t) {
    if (s.length !== t.length) return false;
    
    const count = {};
    
    for (let char of s) {
        count[char] = (count[char] || 0) + 1;
    }
    
    for (let char of t) {
        if (!count[char]) return false;
        count[char]--;
    }
    
    return true;
}

// Example 3: First Unique Character
function firstUniqChar(s) {
    const count = {};
    
    // Count frequencies
    for (let char of s) {
        count[char] = (count[char] || 0) + 1;
    }
    
    // Find first unique
    for (let i = 0; i < s.length; i++) {
        if (count[s[i]] === 1) {
            return i;
        }
    }
    
    return -1;
}
```

#### 2. **Two Sum Pattern**

**Example Problems:**
- [Two Sum](/topics/hash-table#two-sum) - Find two numbers that sum to target
- 4Sum - Find all unique quadruplets that sum to target
- Two Sum II - Two sum in sorted array

```javascript
function twoSum(nums, target) {
    const seen = new Map();
    
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        if (seen.has(complement)) {
            return [seen.get(complement), i];
        }
        seen.set(nums[i], i);
    }
    return [-1, -1];
}
```

#### 3. **Group Anagrams**

**Example Problems:**
- [Group Anagrams](/topics/hash-table#group-anagrams) - Group strings that are anagrams
- [Longest Consecutive Sequence](/topics/hash-table#longest-consecutive-sequence) - Find longest consecutive sequence
- Isomorphic Strings - Check if two strings are isomorphic

```javascript
function groupAnagrams(strs) {
    const groups = new Map();
    
    for (let str of strs) {
        const key = str.split('').sort().join('');
        if (!groups.has(key)) {
            groups.set(key, []);
        }
        groups.get(key).push(str);
    }
    
    return Array.from(groups.values());
}
```

**Time**: O(1) average for operations | **Space**: O(n)

### Key Problems
- [Two Sum](/topics/hash-table#two-sum)
- [Group Anagrams](/topics/hash-table#group-anagrams)
- [Longest Consecutive Sequence](/topics/hash-table#longest-consecutive-sequence)

---

## Stack

### Overview
A stack is a LIFO (Last In, First Out) data structure. Elements are added and removed from the same end (top).

### When to Use
- Matching parentheses/brackets
- Expression evaluation
- Backtracking problems
- Monotonic stack problems

### Common Patterns

#### 1. **Valid Parentheses**

**Example Problems:**
- [Valid Parentheses](/topics/stack#valid-parentheses) - Check if parentheses are valid
- [Generate Parentheses](/topics/stack#generate-parentheses) - Generate all valid parentheses
- Longest Valid Parentheses - Find longest valid parentheses substring

```javascript
// Example 1: Valid Parentheses
function isValid(s) {
    const stack = [];
    const pairs = { '(': ')', '[': ']', '{': '}' };
    
    for (let char of s) {
        if (char in pairs) {
            stack.push(char);
        } else {
            if (stack.length === 0) return false;
            const top = stack.pop();
            if (pairs[top] !== char) return false;
        }
    }
    
    return stack.length === 0;
}

// Example 2: Generate Parentheses
function generateParenthesis(n) {
    const result = [];
    
    function backtrack(current, open, close) {
        if (current.length === 2 * n) {
            result.push(current);
            return;
        }
        
        if (open < n) {
            backtrack(current + '(', open + 1, close);
        }
        if (close < open) {
            backtrack(current + ')', open, close + 1);
        }
    }
    
    backtrack('', 0, 0);
    return result;
}
```

#### 2. **Monotonic Stack**

**Example Problems:**
- Next Greater Element - Find next greater element for each
- [Daily Temperatures](/topics/stack#daily-temperatures) - Days until warmer temperature
- Largest Rectangle in Histogram - Find largest rectangle area

```javascript
// Next Greater Element
function nextGreaterElement(nums) {
    const result = Array(nums.length).fill(-1);
    const stack = [];  // Stores indices
    
    for (let i = 0; i < nums.length; i++) {
        while (stack.length > 0 && nums[i] > nums[stack[stack.length - 1]]) {
            const index = stack.pop();
            result[index] = nums[i];
        }
        stack.push(i);
    }
    
    return result;
}
```

**Time**: O(n) | **Space**: O(n)

### Key Problems
- [Valid Parentheses](/topics/stack#valid-parentheses)
- [Min Stack](/topics/stack#min-stack)
- [Daily Temperatures](/topics/stack#daily-temperatures)

---

## Linked List

### Overview
A linked list is a linear data structure where elements are stored in nodes, and each node points to the next node.

### When to Use
- Dynamic size requirements
- Frequent insertions/deletions
- No random access needed
- Implementing stacks/queues

### Common Patterns

#### 1. **Reverse Linked List**

**Example Problems:**
- [Reverse Linked List](/topics/linked-list#reverse-linked-list) - Reverse a linked list
- Reverse Linked List II - Reverse between positions
- Palindrome Linked List - Check if linked list is palindrome

```javascript
// Example 1: Reverse Linked List
function reverseList(head) {
    let prev = null;
    let current = head;
    
    while (current) {
        const next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    }
    
    return prev;
}

// Example 2: Palindrome Linked List
function isPalindrome(head) {
    if (!head || !head.next) return true;
    
    // Find middle using fast & slow pointers
    let slow = head, fast = head;
    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    // Reverse second half
    let prev = null, current = slow;
    while (current) {
        const next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    }
    
    // Compare both halves
    let left = head, right = prev;
    while (right) {
        if (left.val !== right.val) return false;
        left = left.next;
        right = right.next;
    }
    
    return true;
}
```

#### 2. **Merge Two Sorted Lists**

**Example Problems:**
- [Merge Two Sorted Lists](/topics/linked-list#merge-two-sorted-lists) - Merge two sorted lists
- [Linked List Cycle](/topics/linked-list#linked-list-cycle) - Detect cycle in linked list
- Remove Nth Node From End - Remove nth node from end

```javascript
function mergeTwoLists(l1, l2) {
    const dummy = new ListNode(0);
    let current = dummy;
    
    while (l1 && l2) {
        if (l1.val < l2.val) {
            current.next = l1;
            l1 = l1.next;
        } else {
            current.next = l2;
            l2 = l2.next;
        }
        current = current.next;
    }
    
    current.next = l1 || l2;
    return dummy.next;
}
```

**Time**: O(n) | **Space**: O(1)

### Key Problems
- [Reverse Linked List](/topics/linked-list#reverse-linked-list)
- [Merge Two Sorted Lists](/topics/linked-list#merge-two-sorted-lists)
- [Linked List Cycle](/topics/linked-list#linked-list-cycle)

---

## Graph Algorithms

### Overview
Graphs consist of vertices (nodes) and edges connecting them. Can be directed or undirected, weighted or unweighted.

### Common Algorithms

#### 1. **Topological Sort (Kahn's Algorithm)**

**Example Problems:**
- [Course Schedule](/topics/graph#course-schedule) - Check if can finish all courses
- Course Schedule II - Find order to finish courses
- Alien Dictionary - Find order of characters in alien language

```javascript
function topologicalSort(numCourses, prerequisites) {
    const graph = Array.from({ length: numCourses }, () => []);
    const inDegree = Array(numCourses).fill(0);
    
    // Build graph
    for (let [course, prereq] of prerequisites) {
        graph[prereq].push(course);
        inDegree[course]++;
    }
    
    // Start with nodes having no prerequisites
    const queue = [];
    for (let i = 0; i < numCourses; i++) {
        if (inDegree[i] === 0) queue.push(i);
    }
    
    const result = [];
    while (queue.length > 0) {
        const course = queue.shift();
        result.push(course);
        
        for (let next of graph[course]) {
            inDegree[next]--;
            if (inDegree[next] === 0) {
                queue.push(next);
            }
        }
    }
    
    return result.length === numCourses ? result : [];
}
```

#### 2. **Union Find (Disjoint Set)**

**Example Problems:**
- [Number of Islands](/topics/graph#number-of-islands) - Count number of islands
- Graph Valid Tree - Check if graph is valid tree
- Redundant Connection - Find redundant edge in graph

```javascript
class UnionFind {
    constructor(n) {
        this.parent = Array.from({ length: n }, (_, i) => i);
        this.rank = Array(n).fill(0);
    }
    
    find(x) {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]);  // Path compression
        }
        return this.parent[x];
    }
    
    union(x, y) {
        const rootX = this.find(x);
        const rootY = this.find(y);
        
        if (rootX === rootY) return false;
        
        // Union by rank
        if (this.rank[rootX] < this.rank[rootY]) {
            this.parent[rootX] = rootY;
        } else if (this.rank[rootX] > this.rank[rootY]) {
            this.parent[rootY] = rootX;
        } else {
            this.parent[rootY] = rootX;
            this.rank[rootX]++;
        }
        
        return true;
    }
}
```

### Key Problems
- [Course Schedule](/topics/graph#course-schedule)
- [Number of Islands](/topics/graph#number-of-islands)
- [Clone Graph](/topics/graph#clone-graph)
- [Graph Valid Tree](/topics/graph#graph-valid-tree)

---

## Intervals

### Overview
Interval problems involve working with ranges [start, end]. Common operations include merging, inserting, and finding overlaps.

### Common Patterns

#### 1. **Merge Intervals**

**Example Problems:**
- [Merge Intervals](/topics/intervals#merge-intervals) - Merge overlapping intervals
- [Insert Interval](/topics/intervals#insert-interval) - Insert and merge new interval
- Interval List Intersections - Find intersection of two interval lists

```javascript
// Example 1: Merge Intervals
function merge(intervals) {
    if (intervals.length === 0) return [];
    
    // Sort by start time
    intervals.sort((a, b) => a[0] - b[0]);
    
    const result = [intervals[0]];
    
    for (let i = 1; i < intervals.length; i++) {
        const current = intervals[i];
        const last = result[result.length - 1];
        
        if (current[0] <= last[1]) {
            // Overlapping, merge
            last[1] = Math.max(last[1], current[1]);
        } else {
            // Non-overlapping, add new interval
            result.push(current);
        }
    }
    
    return result;
}

// Example 2: Interval List Intersections
function intervalIntersection(firstList, secondList) {
    const result = [];
    let i = 0, j = 0;
    
    while (i < firstList.length && j < secondList.length) {
        const start = Math.max(firstList[i][0], secondList[j][0]);
        const end = Math.min(firstList[i][1], secondList[j][1]);
        
        if (start <= end) {
            result.push([start, end]);
        }
        
        // Move pointer with smaller end
        if (firstList[i][1] < secondList[j][1]) {
            i++;
        } else {
            j++;
        }
    }
    
    return result;
}
```

#### 2. **Insert Interval**

**Example Problems:**
- Insert Interval - Insert new interval and merge
- Employee Free Time - Find common free time intervals
- [Non-overlapping Intervals](/topics/intervals#non-overlapping-intervals) - Remove minimum intervals

```javascript
function insert(intervals, newInterval) {
    const result = [];
    let i = 0;
    
    // Add all intervals before newInterval
    while (i < intervals.length && intervals[i][1] < newInterval[0]) {
        result.push(intervals[i]);
        i++;
    }
    
    // Merge overlapping intervals
    while (i < intervals.length && intervals[i][0] <= newInterval[1]) {
        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);
        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);
        i++;
    }
    result.push(newInterval);
    
    // Add remaining intervals
    while (i < intervals.length) {
        result.push(intervals[i]);
        i++;
    }
    
    return result;
}
```

#### 3. **Meeting Rooms II (Min Rooms Needed)**

**Example Problems:**
- [Meeting Rooms II](/topics/intervals#meeting-rooms-ii) - Minimum meeting rooms needed
- Car Pooling - Check if can complete all trips
- My Calendar I - Check if event can be booked

```javascript
function minMeetingRooms(intervals) {
    if (intervals.length === 0) return 0;
    
    const starts = intervals.map(i => i[0]).sort((a, b) => a - b);
    const ends = intervals.map(i => i[1]).sort((a, b) => a - b);
    
    let rooms = 0;
    let endPtr = 0;
    
    for (let i = 0; i < starts.length; i++) {
        if (starts[i] < ends[endPtr]) {
            rooms++;  // Need a new room
        } else {
            endPtr++;  // Reuse a room
        }
    }
    
    return rooms;
}
```

**Time**: O(n log n) for sorting | **Space**: O(n)

### Key Problems
- [Merge Intervals](/topics/intervals#merge-intervals)
- [Insert Interval](/topics/intervals#insert-interval)
- [Meeting Rooms II](/topics/intervals#meeting-rooms-ii)
- [Non-overlapping Intervals](/topics/intervals#non-overlapping-intervals)

---

## Summary

This guide covers the most important DSA patterns used in technical interviews. Master these patterns and you'll be able to solve most coding problems efficiently!

### Pattern Selection Strategy

1. **Array/String with contiguous elements** → Sliding Window
2. **Sorted array search** → Binary Search
3. **Two elements in array** → Two Pointers or Hash Table
4. **Tree/Graph traversal** → DFS or BFS
5. **Optimization (min/max)** → Dynamic Programming or Greedy
6. **All combinations/permutations** → Backtracking
7. **Top K elements** → Heap
8. **Fast lookup** → Hash Table
9. **LIFO operations** → Stack
10. **Intervals/ranges** → Intervals pattern

### Practice Resources

- [LeetCode Patterns](https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions)
- [NeetCode Roadmap](https://neetcode.io/roadmap)
- [AlgoMonster](https://algo.monster/)

Happy coding! 🚀